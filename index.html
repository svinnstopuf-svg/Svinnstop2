<!doctype html>
<html lang="sv" translate="no">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Language" content="sv" />
    <meta name="google" content="notranslate" />
    <meta name="googlebot" content="notranslate" />
    <meta name="robots" content="notranslate" />
    <meta property="google" content="notranslate" />
    <meta name="google-translate-customization" content="" />
    <meta name="google-site-verification" content="" />
    <meta name="translation" content="no" />
    <meta name="no-translate" content="true" />
    <meta http-equiv="X-Translate" content="no" />
    <title>Svinnstop</title>
    <style>
      /* Additional anti-translation CSS */
      .notranslate { -webkit-transform: translateZ(0); }
      [translate="no"] { -webkit-transform: translateZ(0); }
      
      /* NUCLEAR LEVEL: Hide ALL Google Translate elements */
      .goog-te-banner-frame, .goog-te-menu-frame, .skiptranslate, .goog-te-gadget, .goog-te-combo,
      .VIpgJd-ZVi9od-ORHb-OEVmcd, .VIpgJd-ZVi9od-xl07Ob-OEVmcd, .gt-bbar-button, .gt-bbar, .gt-c-gap,
      iframe[src*="translate.google"], iframe[src*="translate.googleapis"], iframe[src*="translate"],
      .translate-tooltip, .translate-suggestion-container, [id*="google_translate"], [class*="google_translate"],
      [id*="goog-gt"], [class*="goog-gt"], [id*="translate"], [class*="translate"],
      body > .skiptranslate, body > div[style*="translate"], div[id^="goog-"], div[class^="goog-"],
      script[src*="translate"], link[href*="translate"], style[id*="translate"],
      .goog-tooltip, .goog-menu, .goog-menuitem, .goog-option, .goog-te-spinner,
      [lang]:not([lang="sv"]):not([lang="sv-SE"]), font[style*="background"],
      span[style*="background-color: rgb(255, 255, 0)"], span[style*="background: yellow"],
      *[class*="trans"], *[id*="trans"], *[data-translate], *[translate]:not([translate="no"]) {
        display: none !important; visibility: hidden !important; opacity: 0 !important;
        height: 0 !important; width: 0 !important; overflow: hidden !important;
        position: absolute !important; left: -9999px !important; top: -9999px !important;
        pointer-events: none !important; z-index: -9999 !important; transform: scale(0) !important;
      }
      
      /* Remove Google Translate top bar */
      body.translated-ltr,
      body.translated-rtl {
        margin-top: 0 !important;
      }
      
      /* Hide any floating translate elements */
      body > div:not([id]):not([class]) {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="root" class="notranslate"></div>
    <script>
      // Aggressively disable Google Translate
      (function() {
        // Disable Google Translate initialization
        window.googleTranslateElementInit = function() {};
        
        // Block Google Translate scripts
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) {
                // Remove Google Translate elements
                if (node.classList && (
                  node.classList.contains('skiptranslate') ||
                  node.classList.contains('goog-te-banner-frame') ||
                  node.id && node.id.includes('google_translate')
                )) {
                  node.remove();
                }
                
                // Remove any iframe from translate domains
                if (node.tagName === 'IFRAME' && node.src && (
                  node.src.includes('translate.google') ||
                  node.src.includes('translate.googleapis')
                )) {
                  node.remove();
                }
                
                // Remove scripts from translate domains
                if (node.tagName === 'SCRIPT' && node.src && (
                  node.src.includes('translate.google') ||
                  node.src.includes('translate.googleapis')
                )) {
                  node.remove();
                }
              }
            });
          });
        });
        
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
        
        // Remove translate elements on page load
        document.addEventListener('DOMContentLoaded', function() {
          const elementsToRemove = document.querySelectorAll(`
            .skiptranslate,
            .goog-te-banner-frame,
            .goog-te-menu-frame,
            .goog-te-gadget,
            .gt-bbar,
            iframe[src*="translate.google"],
            [id*="google_translate"],
            [class*="goog-gt"]
          `);
          elementsToRemove.forEach(el => el.remove());
        });
        
        // Override Google Translate functions
        window.google = window.google || {};
        window.google.translate = window.google.translate || {};
        window.google.translate.TranslateElement = function() {};
        
        // Block translate cookie
        Object.defineProperty(document, 'cookie', {
          get: function() {
            return document.cookie.replace(/googtrans=[^;]+;?/g, '');
          },
          set: function(value) {
            if (!value.includes('googtrans')) {
              document.cookie = value;
            }
          }
        });
        
        // Force Swedish language detection
        Object.defineProperty(document, 'documentElement', {
          get: function() {
            const element = document.querySelector('html');
            if (element) {
              element.lang = 'sv';
              element.setAttribute('lang', 'sv');
            }
            return element;
          }
        });
        
        // NUCLEAR: Override ALL language detection
        Object.defineProperty(navigator, 'language', {
          get: function() { return 'sv-SE'; },
          set: function() { return 'sv-SE'; }
        });
        Object.defineProperty(navigator, 'languages', {
          get: function() { return ['sv-SE', 'sv']; },
          set: function() { return ['sv-SE', 'sv']; }
        });
        
        // Block ALL translation networks
        const blockedDomains = [
          'translate.google.com', 'translate.googleapis.com', 'translate-pa.googleapis.com',
          'clients5.google.com', 'clients6.google.com', 'www.gstatic.com',
          'ssl.gstatic.com', 'csi.gstatic.com', 'fonts.gstatic.com'
        ];
        
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
          if (typeof url === 'string' && blockedDomains.some(domain => url.includes(domain))) {
            return Promise.reject(new Error('Translation blocked'));
          }
          return originalFetch.apply(this, arguments);
        };
        
        // Block XMLHttpRequest to translation services
        const originalXHROpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url) {
          if (typeof url === 'string' && blockedDomains.some(domain => url.includes(domain))) {
            throw new Error('Translation request blocked');
          }
          return originalXHROpen.apply(this, arguments);
        };
        
        // Monitor and restore body classes
        const classObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const body = document.body;
              if (body.classList.contains('translated-ltr') || body.classList.contains('translated-rtl')) {
                body.classList.remove('translated-ltr', 'translated-rtl');
                body.style.marginTop = '0';
              }
            }
          });
        });
        
        // NUCLEAR: Text replacement monitor
        let lastCheck = '';
        // THE ULTIMATE REPLACEMENT DICTIONARY - NUCLEAR OPTION
        const swedishReplacements = {
          // Status and time expressions
          'days left': 'dagar kvar',
          'day left': 'dag kvar',
          'days': 'dagar',
          'day': 'dag',
          'left': 'kvar',
          'expires today': 'går ut idag',
          'expires': 'går ut',
          'expired': 'utgången',
          'expiry': 'utgång',
          'minutes': 'minuter',
          'minute': 'minut',
          'seconds': 'sekunder',
          'second': 'sekund',
          
          // Form fields
          'items': 'varor',
          'item': 'vara',
          'quantity': 'antal',
          'name': 'namn',
          'date': 'datum',
          'add item': 'lägg till vara',
          'add': 'lägg till',
          'purchase date': 'inköpsdatum',
          'purchase': 'inköp',
          'expiry date': 'utgångsdatum',
          'all': 'alla',
          
          // UI elements
          'search': 'sök',
          'select': 'välj',
          'delete': 'ta bort',
          'exit': 'avsluta',
          'export': 'exportera',
          'undo': 'ångra',
          'submit': 'skicka',
          'cancel': 'avbryt',
          'ok': 'ok',
          
          // Recipe related
          'recipe suggestions': 'receptförslag',
          'recipe': 'recept',
          'suggestions': 'förslag',
          'ingredients needed': 'ingredienser som behövs',
          'ingredients': 'ingredienser',
          'needed': 'behövs',
          'instructions': 'instruktioner',
          'servings': 'portioner',
          'serving': 'portion',
          'you have': 'du har',
          'you': 'du',
          'have': 'har',
          
          // Difficulty
          'easy': 'lätt',
          'medium': 'medel',
          'hard': 'svår',
          
          // Misc
          'of': 'av',
          'for': 'för',
          'to': 'till',
          'with': 'med',
          'from': 'från',
          'and': 'och',
          'or': 'eller'
        };
        
        // COMPLETE TEXT NODE SCANNER - MOST AGGRESSIVE METHOD POSSIBLE
        function replaceTextInNode(node) {
          if (node.nodeType === 3) { // Text node
            let content = node.textContent;
            let originalContent = content;
            
            // Apply all replacements
            Object.entries(swedishReplacements).forEach(([eng, swe]) => {
              // Only replace whole words, not parts of words
              const regex = new RegExp('\\b' + eng + '\\b', 'gi');
              content = content.replace(regex, swe);
            });
            
            if (content !== originalContent) {
              node.textContent = content;
            }
          }
          else if (node.nodeType === 1) { // Element node
            // Check attributes that might contain text
            ['title', 'alt', 'placeholder', 'aria-label'].forEach(attr => {
              if (node.hasAttribute(attr)) {
                let content = node.getAttribute(attr);
                let originalContent = content;
                
                Object.entries(swedishReplacements).forEach(([eng, swe]) => {
                  const regex = new RegExp('\\b' + eng + '\\b', 'gi');
                  content = content.replace(regex, swe);
                });
                
                if (content !== originalContent) {
                  node.setAttribute(attr, content);
                }
              }
            });
            
            // Process children recursively
            Array.from(node.childNodes).forEach(child => {
              replaceTextInNode(child);
            });
          }
        }
        
        function aggressiveSwedishRestore() {
          // First process all text nodes individually for maximum precision
          if (document.body) {
            replaceTextInNode(document.body);
          }
          
          // Then do a full HTML check as backup
          const currentHTML = document.body.innerHTML;
          if (currentHTML !== lastCheck) {
            let newHTML = currentHTML;
            Object.entries(swedishReplacements).forEach(([eng, swe]) => {
              const regex = new RegExp('\\b' + eng + '\\b', 'gi');
              newHTML = newHTML.replace(regex, swe);
            });
            
            if (newHTML !== currentHTML) {
              document.body.innerHTML = newHTML;
            }
            lastCheck = newHTML;
          }
        }
        
        // ULTRA FAST: Run every 50ms + on every possible event
        setInterval(aggressiveSwedishRestore, 50);
        
        // Monitor EVERY possible DOM change
        const superObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
              // Process new nodes immediately
              Array.from(mutation.addedNodes).forEach(node => {
                if (node.nodeType === 1 || node.nodeType === 3) {
                  replaceTextInNode(node);
                }
              });
            }
            if (mutation.type === 'characterData') {
              // Text content changed, fix it immediately
              replaceTextInNode(mutation.target);
            }
          });
        });
        
        // Start monitoring immediately when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', function() {
            superObserver.observe(document.documentElement, {
              childList: true,
              subtree: true,
              characterData: true,
              attributes: true
            });
            aggressiveSwedishRestore();
          });
        } else {
          superObserver.observe(document.documentElement, {
            childList: true,
            subtree: true,
            characterData: true,
            attributes: true
          });
          aggressiveSwedishRestore();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
          classObserver.observe(document.body, {
            attributes: true,
            attributeFilter: ['class', 'style', 'lang', 'translate']
          });
          
          // Immediate cleanup
          aggressiveSwedishRestore();
        });
        // NUCLEAR: Block script injections and dynamic loading
        const originalCreateElement = document.createElement;
        document.createElement = function(tagName) {
          const element = originalCreateElement.call(this, tagName);
          if (tagName.toLowerCase() === 'script') {
            const originalSetAttribute = element.setAttribute;
            element.setAttribute = function(name, value) {
              if (name === 'src' && typeof value === 'string' && 
                  (value.includes('translate') || value.includes('google'))) {
                return; // Block translate scripts
              }
              return originalSetAttribute.call(this, name, value);
            };
          }
          return element;
        };
        
        // Force Swedish content at all times
        Object.defineProperty(document, 'textContent', {
          set: function(value) {
            if (typeof value === 'string') {
              Object.entries(swedishReplacements).forEach(([eng, swe]) => {
                value = value.replace(new RegExp(eng, 'gi'), swe);
              });
            }
            return value;
          }
        });
        
        // Block window.postMessage to translation services
        const originalPostMessage = window.postMessage;
        window.postMessage = function(message, targetOrigin) {
          if (typeof targetOrigin === 'string' && 
              (targetOrigin.includes('translate') || targetOrigin.includes('google'))) {
            return; // Block translation messages
          }
          return originalPostMessage.apply(this, arguments);
        };
      })();
    </script>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
